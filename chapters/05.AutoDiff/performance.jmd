---
title : Performance in Julia
author : Michiel Stock
date: 2019-2020
---


```julia
using BenchmarkTools, Plots, LinearAlgebra
```

```julia
function randdrift(x0; n_steps=1000, σ=1)
  x = x0
  for i in 1:n
    x += σ * randn(size(x))
    # x = x + σ * randn(size(x))  # this line is exactly the same!
  end
  return x
end

x0 = zeros(1000)
@btime randdrift(x0);
```

```julia
function randdrift2(x0; n_steps=1000, σ=1)
  x = x0
  for i in 1:n
    x .+= σ * randn(size(x))
  end
  return x
end

x0 = zeros(1000)
@btime randdrift2(x0);
```

```julia
function randdrift3(x0; n_steps=1000, σ=1)
  x = x0
  for i in 1:n
    @. x += σ * randn(size(x))
    # x .+= σ .* randn(size(x))  # this line is exactly the same!
    # x .= x .+ σ .* randn(size(x))  # this line is exactly the same!
  end
  return x
end

x0 = zeros(1000)
@btime randdrift3(x0);
```

```julia; term=true
f(x) = sin.(x) + x.^2 + 3x
fdot(x) = @. sin(x) + x^2 + 3x
x = randn(10^6);
@btime f(x)  # this function creates intermediate arrays
@btime fdot(x)  # this one processes the input vector element-by-element
@btime f.(x)  # this one does that as well, but it is enforced during run time
```

# Avoid global constants

```julia; term=true
c = 299792458
energy(m) = m * c^2
m0 = 1.2
@btime energy(m0)
const C = 299792458  # captital letters indicate constants by convention
energy2(m) = m * C^2
@btime energy2(m0)
```
